# {{ required "A configuration.filestore.cache URI needs to be define. See assemblyline manual." .Values.configuration.filestore.cache }}
# {{ required "A configuration.filestore.storage URI needs to be define. See assemblyline manual." .Values.configuration.filestore.storage }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: elasticsearch-indexes
data:
  elastic-alert-shards: "{{ .Values.elasticAlertShards }}"
  elastic-default-replicas: "{{ .Values.elasticDefaultReplicas }}"
  elastic-default-shards: "{{ .Values.elasticDefaultShards }}"
  elastic-emptyresult-shards: "{{ .Values.elasticEmptyResultShards }}"
  elastic-file-shards: "{{ .Values.elasticFileShards }}"
  elastic-filescore-shards: "{{ .Values.elasticFileScoreShards }}"
  elastic-result-shards: "{{ .Values.elasticResultShards }}"
  elastic-safelist-shards: "{{ .Values.elasticSafelistShards }}"
  elastic-submission-shards: "{{ .Values.elasticSubmissionShards }}"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: system-settings
data:
  datastore-ssl-enabled: {{ .Values.enableInternalEncryption | quote }}
  datastore-ssl-key: {{ if .Values.enableInternalEncryption }}"/usr/share/elasticsearch/config/http_ssl/tls.key"{{ else }}''{{ end }}
  datastore-ssl-cert: {{ if .Values.enableInternalEncryption }}"/usr/share/elasticsearch/config/http_ssl/tls.crt"{{ else }}''{{ end }}
  logging-host: {{ if .Values.seperateInternalELKStack}}log-storage-master:9200{{ else if .Values.internalELKStack }}datastore-master:9200{{ else }}{{ .Values.loggingHost | default "localhost:9200" }}{{ end }}
  logging-username: {{ if .Values.internalELKStack }}elastic{{ else }}{{ .Values.loggingUsername }}{{ end }}
  logging-tls-verify: {{ .Values.loggingTLSVerify }}
  logging-ssl-enabled: {{ .Values.enableInternalEncryption | quote }}
  logging-ssl-key: {{ if .Values.enableInternalEncryption }}"/usr/share/elasticsearch/config/http_ssl/tls.key"{{ else }}''{{ end }}
  logging-ssl-cert: {{ if .Values.enableInternalEncryption }}"/usr/share/elasticsearch/config/http_ssl/tls.crt"{{ else }}''{{ end }}
  logging-ca: {{ if .Values.enableInternalEncryption }}"/etc/certs/ca.crt"{{ else }}''{{ end }}
  logging-protocol: {{ if .Values.enableInternalEncryption }}"https"{{ else }}"http"{{ end }}
  metricbeat-index-prefix: {{ .Values.metricbeatIndexPrefix }}



---
{{ if .Values.enableHSTSHeader }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-config
data:
  serve.json: |
    {
      "headers": [
        {
          "source":"**/*",
          "headers": [
              {
                "key": "Strict-Transport-Security",
                "value": "max-age={{ .Values.HSTSMaxAge }};includeSubDomains"
              }
          ]
        }
      ]
    }
---
{{ end }}
# The assemblyline config that will be projected into all the assemblyline pods
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-global-config
data:
  config: |
{{ .Values.configuration | toYaml | indent 4 }}
  {{- if not ( and .Values.classification.configMap .Values.classification.key ) }}
  classification: |
    # Turn on/off classification enforcement. When this flag is off, this
    #  completely disables the classification engine, any documents added while
    #  the classification engine is off getting the default unrestricted value
    enforce: false

    # When this flag is on, the classification engine will automatically create
    #  groups based on the domain part of a user's email address
    #  EX:
    #     For user with email: test@local.host
    #     The group "local.host" will be valid in the system
    dynamic_groups: false

    # List of Classification Levels:
    #   This is a graded list; a smaller number is less restricted than a higher number
    #   A user must be allowed a classification level >= to be able to view the data
    levels:
      # List of alternate names for the current marking. If a user submits a file with
      #  those markings, the classification will automatically rename it to the value
      #  specified in the name
      - aliases:
          - UNRESTRICTED
          - UNCLASSIFIED
          - U
          - TLP:W
          - TLP:WHITE
        # Stylesheet applied in the UI for the current classification level
        css:
          # Name of the color scheme used for display
          # Possible values: default, primary, secondary, success, info, warning, error
          color: default

          # Deprecated parameters (Use color instead)
          #  These were used in the old UI but are still valid in the new UI because if
          #  the new UI cannot find the color param, it will use the label param and
          #  strips "label-" part.
          banner: alert-default
          label: label-default
          text: text-muted

        # Description of the classification level
        description:
          Subject to standard copyright rules, TLP:CLEAR information may be distributed
          without restriction.

        # Integer value of the Classification level (higher is more classified)
        lvl: 100

        # Long name of the classification level
        name: TLP:CLEAR

        # Short name of the classification level
        short_name: TLP:C
      - aliases: []
        css:
          color: success
        description:
          Recipients may share TLP:GREEN information with peers and partner organizations
          within their sector or community, but not via publicly accessible channels.
          Information in this category can be circulated widely within a particular
          community. TLP:GREEN information may not be released outside of the community.
        lvl: 110
        name: TLP:GREEN
        short_name: TLP:G
      - aliases:
          - RESTRICTED
        css:
          color: warning
        description:
          Recipients may only share TLP:AMBER information with members of their
          own organization and with clients or customers who need to know the information
          to protect themselves or prevent further harm.
        lvl: 120
        name: TLP:AMBER
        short_name: TLP:A

    # List of required tokens:
    #   A user requesting access to an item must have all the
    #   required tokens the item has, to gain access to it
    required:
      # List of alternate names for the token
      - aliases: []

        # Description of the token
        description: Produced using a commercial tool with limited distribution

        # Long name for the token
        name: COMMERCIAL

        # Short name for the token
        short_name: CMR

        # (optional) The minimum classification level an item must have
        #  for this token to be valid. So, because this token has a value
        #  of 120, once it's selected, the classification level automatically
        #  jumps to TPL:A which was set to 120 in the previous section.
        require_lvl: 120

    # List of groups:
    #   A user requesting access to an item must be part of a least
    #   of one the group the item is part of to gain access
    groups:
      # List of aliases for the group
      - aliases:
          - ANY
        # (optional) This is a special flag that when set to true if any other groups
        #  are selected in a classification, this group will automatically be selected
        #  as well.
        auto_select: true

        # Description of the group
        description: Employees of CSE

        # Long name for the group
        name: CSE

        # Short name for the group
        short_name: CSE

        # (optional) Assuming that this group is the only group selected, this is the
        #   display name that will be used in the classification
        #   NOTE: values must be in the aliases of this group and only this group
        solitary_display_name: ANY

    # List of sub-groups:
    #   A user requesting access to an item must be part of a least
    #   of one the sub-group the item is part of to gain access
    subgroups:
      # List of aliases for the subgroups
      - aliases: []

        # Description of the sub-group
        description: Member of Incident Response team

        # Long name of the sub-group
        name: IR TEAM

        # Short name of the sub-group
        short_name: IR
      - aliases: []
        description: Member of the Canadian Centre for Cyber Security

        # (optional) This is a special flag that auto select the corresponding
        #   group when this sub-group is selected
        require_group: CSE

        name: CCCS
        short_name: CCCS

        # (optional) This is a special flag that makes sure that none other then
        #   the corresponding group is selected when this sub-group is selected
        limited_to_group: CSE

    # Default restricted classification
    restricted: TLP:A//CMR

    # Default unrestricted classification:
    #   When no classification is provided or the classification engine is
    #   disabled, this is the classification value each item will get
    unrestricted: TLP:C
  {{- end }}

{{ if .Values.useReplay }}
---
# The replay config that will be use in the replay containers
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-replay-config
data:
  replay: |
{{ .Values.replay | toYaml | indent 4 }}
{{end}}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-bootstrap-script
data:
  bootstrap.py: |
    from assemblyline.odm.models.user_settings import UserSettings
    from assemblyline.common.security import get_password_hash
    from assemblyline.odm.models.user import User
    from assemblyline.common import forge
    import os

    ADMIN_USER = 'admin'
    INITIAL_ADMIN_PASSWORD = os.environ['INITIAL_ADMIN_PASSWORD']
    Classification = forge.get_classification()

    if __name__ == '__main__':
        ds = forge.get_datastore()
        if not ds.user.get_if_exists(ADMIN_USER):
            user_data = User({
                "agrees_with_tos": "NOW",
                "classification": Classification.RESTRICTED,
                "name": "Administrator",
                "password": get_password_hash(INITIAL_ADMIN_PASSWORD),
                "uname": ADMIN_USER,
                "type": [ADMIN_USER, "user", "signature_importer"]})
            ds.user.save(ADMIN_USER, user_data)
            ds.user_settings.save(ADMIN_USER, UserSettings())
            print("Initial user setup finished.")
        else:
            print(f"User {ADMIN_USER} already found, system is already setup.")
  share_certificate.py: |
    import os
    import logging
    from flask import Flask, request, abort

    app = Flask(__name__)

    FILES = {
        'elastic-certificates.p12': '/data/elastic-certificates.p12',
        'elastic-stack-ca.p12': '/data/elastic-stack-ca.p12'
    }

    @app.route("/<filename>")
    def read_file(filename):
        if request.headers.get('Authorization', '') != 'Bearer ' + os.environ['SECRET_KEY']:
            abort(401, 'token refused')

        if filename not in FILES:
            abort(404)

        return open(FILES[filename], 'rb').read()

    if __name__ == "__main__":
        logging.basicConfig(level=logging.INFO)
        app.run(ssl_context='adhoc', host='0.0.0.0', port=8000)
---
# The ConfigMap to initialize service account for Kibana
apiVersion: v1
kind: ConfigMap
metadata:
  name: init-kibana-token
data:
  create_serviceaccount_token.py: |
    import os
    import requests
    from datetime import datetime
    from kubernetes import client, config
    from kubernetes.client import V1Secret, V1ObjectMeta

    if __name__ == "__main__":
      # Try loading a kubernetes connection from either the fact that we are running
      # inside of a cluster, or have a config file that tells us how
      try:
          config.load_incluster_config()
      except config.config_exception.ConfigException:
          # Load the configuration once to initialize the defaults
          config.load_kube_config()
          # Now we can actually apply any changes we want to make
          cfg = client.configuration.Configuration(client.configuration.Configuration)
          if 'HTTPS_PROXY' in os.environ:
              cfg.proxy = os.environ['HTTPS_PROXY']
              if not cfg.proxy.startswith("http"):
                  cfg.proxy = "https://" + cfg.proxy
              client.Configuration.set_default(cfg)
          # Load again with our settings set
          config.load_kube_config(client_configuration=cfg)

      base = os.environ['LOGGING_BASEURL']
      auth = (os.environ['LOGGING_USERNAME'], os.environ['LOGGING_PASSWORD'])
      verify = "/etc/assemblyline/ssl/al_root-ca.crt" if os.path.exists("/etc/assemblyline/ssl/al_root-ca.crt") else True
      # Delete existing token
      requests.delete(f"{base}/_security/service/elastic/kibana/credential/token/kibana", auth=auth, verify=verify)
      # Create a new token
      resp = requests.post(f"{base}/_security/service/elastic/kibana/credential/token/kibana", auth=auth, verify=verify).json()
      core_api = client.CoreV1Api()
      core_api.patch_namespaced_secret(name="kibana-service-token", namespace=os.getenv('NAMESPACE', 'al'), body=V1Secret(metadata=V1ObjectMeta(name="kibana-service-token"), string_data={"token": resp['token']['value']}))
      # Restart Kibana deployment
      now = datetime.utcnow()
      now = str(now.isoformat("T") + "Z")
      body = {
          'spec': {
              'template':{
                  'metadata': {
                      'annotations': {
                          'kubectl.kubernetes.io/restartedAt': now
                      }
                  }
              }
          }
      }
      client.AppsV1Api().patch_namespaced_deployment("kibana", namespace=os.getenv('NAMESPACE', 'al'), body=body, pretty='true')
